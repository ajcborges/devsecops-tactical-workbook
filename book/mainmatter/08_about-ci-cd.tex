\makeatletter
\@removefromreset{figure}{section}
\@addtoreset{figure}{chapter}
\renewcommand{\thefigure}{\thechapter.\@arabic\c@figure}
\makeatother

\hypertarget{continuous-integration-deployment}{%
\section{Continuous Integration \&
Deployment}\label{continuous-integration-deployment}}

\includegraphics{../images/finland-905712_1920.jpg}

Accomodations for Continuous Integration (CI) \& Continuous Deployment
(CD) in our projects directly corresponds to our chances of success.

single: CI single: Continuous Deployment single: CD single: Continuous
Integration

\hypertarget{linters}{%
\subsection{Linters}\label{linters}}

There are small programs for most (every?) language that you can run
before pushing your changes to GitHub that will catch syntactical and
sometimes even programmatic issues. Consider Python, which is very
sensitive with regard to indentation. You can programatiacally detect
and even correct issues before your work gets too far down the pipe.
This is also a good way to make sure folks are not committing dirty code
to your repositories.

single: lint single: linters

Here are some of the linters I have found useful for languages I
encounter frequently.

\begin{longtable}[]{@{}lll@{}}
\caption{Linters}\tabularnewline
\toprule
Language & Name & Source\tabularnewline
\midrule
\endfirsthead
\toprule
Language & Name & Source\tabularnewline
\midrule
\endhead
Ansible & ansible-lint & python (pip install
ansible-lint)\tabularnewline
Markdown & mdl & ruby (gem install mdl)\tabularnewline
Puppet & puppet-lint & ruby (gem install puppet-lint)\footnote{\url{http://puppet-lint.com/}}\tabularnewline
Python & pylint/flake8 & python (pip install
pylint/flake8)\tabularnewline
Terraform & tflint &
\url{https://github.com/terraform-linters/tflint}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{linting-with-tox}{%
\subsection{Linting with Tox}\label{linting-with-tox}}

Recall that we are using Tox as our main test framework. To set up Tox
to do our linting work for us, we can add an environment to our envlist
called "pylint" and then declare it in a new stanza in tox.ini. Notice
how we let "deps" do the work of installing the "pylint" dependency for
us.

single: pylint

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[tox]}
\NormalTok{ envlist }\OperatorTok{=}\NormalTok{ py38. pylint}
\NormalTok{ skip_missing_interpreters }\OperatorTok{=}\NormalTok{ true}

\NormalTok{[pylint]}
\NormalTok{deps }\OperatorTok{=}
\NormalTok{  pylint}
\NormalTok{commands}\OperatorTok{=}
  \CommentTok{# the -rn flag will suppress report output (warnings)}
\NormalTok{  pylint }\OperatorTok{-}\NormalTok{rn }\OperatorTok{--}\NormalTok{rcfile}\OperatorTok{=}\NormalTok{.pylintrc my_resume}\OperatorTok{/}\NormalTok{my_resume.py}
\end{Highlighting}
\end{Shaded}

\hypertarget{github-actions}{%
\subsection{GitHub Actions}\label{github-actions}}

GitHub Actions is a recent introduction to the github.com website that
lets you perform Continuous Integration on your repository, and
Continuous Deployment as desired.

single: GitHub Actions

\hypertarget{docker}{%
\subsubsection{Docker}\label{docker}}

Let's see how we can leverage Actions to build the docker target in our
project. Save this YAML file under
codelab/.github/workflows/docker\_compose.yml to have GitHub Actions
execute our make docker target from our custom Makefile.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{---}
\FunctionTok{name:}\AttributeTok{ DevSecOps Docker Image CI}
\FunctionTok{on:}
  \FunctionTok{push:}
    \FunctionTok{branches:}\AttributeTok{ }\KeywordTok{[}\NormalTok{ master }\KeywordTok{]}
  \FunctionTok{pull_request:}
    \FunctionTok{branches:}\AttributeTok{ }\KeywordTok{[}\NormalTok{ master }\KeywordTok{]}
\FunctionTok{jobs:}
  \FunctionTok{build:}
    \FunctionTok{runs-on:}\AttributeTok{ ubuntu-latest}
    \FunctionTok{env:}
      \FunctionTok{SHODAN_KEY:}\AttributeTok{ $\{\{ secrets.shodanKey \}\}}
    \FunctionTok{steps:}
    \KeywordTok{-} \FunctionTok{uses:}\AttributeTok{ actions/checkout@v2}
    \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ Set up Python 3.8}
      \FunctionTok{uses:}\AttributeTok{ actions/setup-python@v1}
      \FunctionTok{with:}
        \FunctionTok{python-version:}\AttributeTok{ }\FloatTok{3.8}
    \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ Build the docker-compose stack}
\FunctionTok{      run:} \StringTok{|}
\NormalTok{        sudo apt -y install python3-setuptools}
\NormalTok{        make docker}
\end{Highlighting}
\end{Shaded}

\hypertarget{python}{%
\subsubsection{Python}\label{python}}

Save this YAML file under codelab/.github/workflows/python.yml to have
GitHub Actions execute our make python target from our custom Makefile.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{---}
\FunctionTok{name:}\AttributeTok{ DevSecOps Python CI}
\FunctionTok{on:}
  \FunctionTok{push:}
    \FunctionTok{branches:}\AttributeTok{ }\KeywordTok{[}\NormalTok{ master }\KeywordTok{]}
  \FunctionTok{pull_request:}
    \FunctionTok{branches:}\AttributeTok{ }\KeywordTok{[}\NormalTok{ master }\KeywordTok{]}
\FunctionTok{jobs:}
  \FunctionTok{build:}
    \FunctionTok{runs-on:}\AttributeTok{ ubuntu-latest}
    \FunctionTok{steps:}
    \KeywordTok{-} \FunctionTok{uses:}\AttributeTok{ actions/checkout@v2}
    \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ Set up Python 3.8}
      \FunctionTok{uses:}\AttributeTok{ actions/setup-python@v1}
      \FunctionTok{with:}
        \FunctionTok{python-version:}\AttributeTok{ }\FloatTok{3.8}
    \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ Install dependencies}
      \FunctionTok{run:}\AttributeTok{ make python}
    \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ Lint with flake8}
\FunctionTok{      run:} \StringTok{|}
\NormalTok{        pip install flake8}
\NormalTok{        # stop the build if there are Python syntax errors or undefined names}
\NormalTok{        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics}
\NormalTok{        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide}
\NormalTok{        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics}
    \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ Test with pytest}
\FunctionTok{      run:} \StringTok{|}
\NormalTok{        sudo mkdir -p /var/log/devsecops}
\NormalTok{        sudo chmod 777 /var/log/devsecops}
\NormalTok{        make test}
\end{Highlighting}
\end{Shaded}

\hypertarget{packer}{%
\subsubsection{Packer}\label{packer}}

Save this YAML file under devsecops/.github/workflows/packer.yml to have
GitHub Actions validate and build our AMI image with Packer.

single: Packer

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{---}
  \FunctionTok{name:}\AttributeTok{ Packer}
  \FunctionTok{on:}
    \FunctionTok{push:}
  \FunctionTok{jobs:}
    \FunctionTok{packer:}
      \FunctionTok{runs-on:}\AttributeTok{ ubuntu-latest}
      \FunctionTok{name:}\AttributeTok{ packer}
      \FunctionTok{steps:}
        \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ Checkout Repository}
          \FunctionTok{uses:}\AttributeTok{ actions/checkout@v2}
        \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ Python setup}
          \FunctionTok{uses:}\AttributeTok{ actions/setup-python@v1}
          \FunctionTok{with:}
            \FunctionTok{python-version:}\AttributeTok{ }\StringTok{'3.8'} \CommentTok{# Version range or exact version of a Python version to use, using SemVer's version range syntax}
            \FunctionTok{architecture:}\AttributeTok{ }\StringTok{'x64'} \CommentTok{# optional x64 or x86. Defaults to x64 if not specified}
        \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ Install Python Goodies}
          \FunctionTok{run:}\AttributeTok{ python -m pip install -rpython/requirements.txt}
        \CommentTok{# fix backwards incompatibilities in template}
        \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ Fix Template}
          \FunctionTok{uses:}\AttributeTok{ operatehappy/packer-github-actions@master}
          \FunctionTok{with:}
            \FunctionTok{command:}\AttributeTok{ fix}
            \FunctionTok{target:}\AttributeTok{ packer/aws-debian-host.json}
        \CommentTok{# validate templates}
        \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ Validate Template}
          \FunctionTok{uses:}\AttributeTok{ operatehappy/packer-github-actions@master}
          \FunctionTok{with:}
            \FunctionTok{command:}\AttributeTok{ validate}
            \FunctionTok{arguments:}\AttributeTok{ -syntax-only}
            \FunctionTok{target:}\AttributeTok{ packer/aws-debian-host.json}

        \CommentTok{# build artifact}
        \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ Build Artifact}
          \FunctionTok{uses:}\AttributeTok{ operatehappy/packer-github-actions@master}
          \FunctionTok{with:}
            \FunctionTok{command:}\AttributeTok{ build}
            \FunctionTok{target:}\AttributeTok{ packer/aws-debian-host.json}
            \FunctionTok{arguments:}\AttributeTok{ }\StringTok{"-color=false -on-error=abort"}
\end{Highlighting}
\end{Shaded}

\hypertarget{markdown}{%
\subsubsection{Markdown}\label{markdown}}

The following example YAML file illustrates how to validate GitHub
flavored Markdown text files using a GitHub Action.

single: Markdown single: markdownlint

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{name:}\AttributeTok{ CI}
\FunctionTok{on:}
  \FunctionTok{push:}
    \FunctionTok{branches:}\AttributeTok{ }\KeywordTok{[}\NormalTok{ master }\KeywordTok{]}
  \FunctionTok{pull_request:}
    \FunctionTok{branches:}\AttributeTok{ }\KeywordTok{[}\NormalTok{ master }\KeywordTok{]}
\FunctionTok{jobs:}
  \FunctionTok{build:}
    \FunctionTok{runs-on:}\AttributeTok{ ubuntu-latest}
    \FunctionTok{steps:}
    \KeywordTok{-} \FunctionTok{uses:}\AttributeTok{ actions/checkout@v2}
    \KeywordTok{-} \FunctionTok{name:}\AttributeTok{ markdownlint-cli}
      \FunctionTok{uses:}\AttributeTok{ nosborn/github-action-markdown-cli@v1.1.1}
      \FunctionTok{with:}
        \FunctionTok{files:}\AttributeTok{ .}
      \FunctionTok{config_file:}\AttributeTok{ }\StringTok{".markdownlint.json"}
\end{Highlighting}
\end{Shaded}

Note the designation of a configuration file named .markdownlint.json at
the top level of our repository. This JSON file is used to skip certain
checks by the markdownlint tool.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{}
    \DataTypeTok{"default"}\FunctionTok{:} \KeywordTok{true}\FunctionTok{,}
    \DataTypeTok{"MD013"}\FunctionTok{:} \KeywordTok{false}\FunctionTok{,}
    \DataTypeTok{"MD033"}\FunctionTok{:} \KeywordTok{false}\FunctionTok{,}
    \DataTypeTok{"MD041"}\FunctionTok{:} \KeywordTok{false}\FunctionTok{,}
    \DataTypeTok{"MD047"}\FunctionTok{:} \KeywordTok{false}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{circle-ci}{%
\subsection{Circle CI}\label{circle-ci}}

Circle CI is a Continuous Integation service free for non-commercial
projects.

single: Circle CI

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Python CircleCI 2.0 configuration file}
\CommentTok{# }
\CommentTok{# Check https://circleci.com/docs/2.0/language-python/ for more details}
\CommentTok{# }
\FunctionTok{version:}\AttributeTok{ }\DecValTok{2}
\FunctionTok{jobs:}
  \FunctionTok{build:}
    \FunctionTok{docker:}
      \CommentTok{# specify the version you desire here}
      \CommentTok{# use `-browsers` prefix for selenium tests, e.g. `3.6.1-browsers`}
      \KeywordTok{-} \FunctionTok{image:}\AttributeTok{ circleci/python:3.6.1}
        \FunctionTok{environment:}
          \FunctionTok{FLASK_APP:}\AttributeTok{ my_resume.py}
          \FunctionTok{FLASK_DEBUG:}\AttributeTok{ }\DecValTok{1}
    \CommentTok{# Specify service dependencies here if necessary}
    \CommentTok{# CircleCI maintains a library of pre-built images}
    \CommentTok{# documented at https://circleci.com/docs/2.0/circleci-images/}
    \CommentTok{# - image: circleci/postgres:9.4}
    \FunctionTok{working_directory:}\AttributeTok{ ~/repo}
    \FunctionTok{steps:}
      \KeywordTok{-}\NormalTok{ checkout}
    \CommentTok{# Download and cache dependencies}
      \KeywordTok{-} \FunctionTok{restore_cache:}
          \FunctionTok{keys:}
            \KeywordTok{-}\NormalTok{ v1-dependencies-}\KeywordTok{\{}\NormalTok{\{ checksum }\StringTok{"requirements/requirements.dev"} \KeywordTok{\}}\NormalTok{\}}
            \CommentTok{# fallback to using the latest cache if no exact match is found}
            \KeywordTok{-}\NormalTok{ v1-dependencies-}
      \KeywordTok{-} \FunctionTok{run:}
          \FunctionTok{name:}\AttributeTok{ install dependencies}
\FunctionTok{          command:} \StringTok{|}
\NormalTok{            python3 -m pip install --user virtualenv}
\NormalTok{            ~/.local/bin/virtualenv venv}
\NormalTok{            . venv/bin/activate}
\NormalTok{            python3 -m pip install -r requirements/requirements.dev}
  \FunctionTok{test:}
    \FunctionTok{docker:}
      \KeywordTok{-} \FunctionTok{image:}\AttributeTok{ circleci/python:3.6.1}
        \FunctionTok{environment:}
          \FunctionTok{FLASK_APP:}\AttributeTok{ my_resume.py}
          \FunctionTok{FLASK_DEBUG:}\AttributeTok{ }\DecValTok{1}
    \FunctionTok{working_directory:}\AttributeTok{ ~/repo}
    \FunctionTok{steps:}
      \KeywordTok{-}\NormalTok{ checkout}
    \CommentTok{# Download and cache dependencies}
      \KeywordTok{-} \FunctionTok{restore_cache:}
          \FunctionTok{keys:}
            \KeywordTok{-}\NormalTok{ v1-dependencies-}\KeywordTok{\{}\NormalTok{\{ checksum }\StringTok{"requirements/requirements.dev"} \KeywordTok{\}}\NormalTok{\}}
            \CommentTok{# fallback to using the latest cache if no exact match is found}
            \KeywordTok{-}\NormalTok{ v1-dependencies-}
      \KeywordTok{-} \FunctionTok{run:}\AttributeTok{ }
          \FunctionTok{name:}\AttributeTok{ run tests}
\FunctionTok{          command:} \StringTok{|}
\NormalTok{            python3 -m pip install --user virtualenv}
\NormalTok{            python3 -m pip install --user tox}
\NormalTok{            #~/.local/bin/virtualenv venv}
\NormalTok{            #. venv/bin/activate}
\NormalTok{            #python3 -m pip install --user -r requirements/requirements.dev}
\NormalTok{            echo "lets do some testing"}
\NormalTok{            # move test commands to tox.ini}
\NormalTok{            #~/.local/bin/tox -e venv}
\NormalTok{            ~/.local/bin/tox}
\FunctionTok{workflows:}
  \FunctionTok{version:}\AttributeTok{ }\DecValTok{2}
  \FunctionTok{build_and_test:}
    \FunctionTok{jobs:}
      \KeywordTok{-}\NormalTok{ build}
      \KeywordTok{-}\NormalTok{ test}
\end{Highlighting}
\end{Shaded}

\hypertarget{travisci}{%
\subsection{TravisCI}\label{travisci}}

Travis CI is a hosted continuous integration service used to build and
test software projects hosted at GitHub and Bitbucket. They have a great
tutorial available\footnote{\url{https://docs.travis-ci.com/user/tutorial/}}
if you care to dig a bit deeper.

By enabling Travis CI integration through the GitHub
Marketplace\footnote{\url{https://github.com/marketplace/travis-ci}} you
can integrate their scanners with your repository.

single: Travis CI

\hypertarget{docker-1}{%
\subsubsection{Docker}\label{docker-1}}

You can test Docker containers in your CI/CD pipeline. As seen in the
following example I created a YAML file named .travis.yml to enable
automatic molecule testing of ansible roles in Travis CI. I also set a
flag in the repo settings that prevent the PR from being merged until
Travis CI flags the build as passing.

single: Docker single: Molecule

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{---}
\FunctionTok{sudo:}\AttributeTok{ required}
\FunctionTok{dist:}\AttributeTok{ xenial   }\CommentTok{# required for Python >= 3.7}
\FunctionTok{language:}\AttributeTok{ python}
\FunctionTok{services:}\AttributeTok{ }
  \KeywordTok{-}\NormalTok{ docker}
\FunctionTok{python:}
  \KeywordTok{-} \StringTok{"3.7"}
  \KeywordTok{-} \StringTok{"3.8"}
\FunctionTok{before_install:}
  \KeywordTok{-}\NormalTok{ sudo apt-get -qq update}
  \KeywordTok{-}\NormalTok{ python3 -m pip install wheel}
  \KeywordTok{-}\NormalTok{ python3 -m pip install -rrequirements.txt}
  \KeywordTok{-}\NormalTok{ python3 -m pip install -rrequirements-test.txt}
\FunctionTok{script:}\AttributeTok{ }
  \KeywordTok{-}\NormalTok{ cd playbooks/roles/webserver && molecule test}
\end{Highlighting}
\end{Shaded}

The contents of the requirements files and the example Ansible code is
available in the companion repo.

\hypertarget{markdown-1}{%
\subsubsection{Markdown}\label{markdown-1}}

Save these lines to a file named .travis.yml to scan all the markdown
files in your repository.

single: Markdown

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{---}
\FunctionTok{sudo:}\AttributeTok{ required}
\FunctionTok{services:}
  \KeywordTok{-}\NormalTok{ docker    }
\FunctionTok{before_install:}
  \KeywordTok{-}\NormalTok{ sudo apt-get -qq update}
  \KeywordTok{-}\NormalTok{ gem install mdl --no-ri --no-rdoc}
\FunctionTok{script:}
  \KeywordTok{-}\NormalTok{ mdl -c .mdlrc .}
\end{Highlighting}
\end{Shaded}

You can also create an .mdlrc file to give mdl direction on what to scan
for.

single: .mdlrc

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{rules} \StringTok{"MD001"}\NormalTok{ ,}\StringTok{"MD002"}\NormalTok{ ,}\StringTok{"MD003"}\NormalTok{ ,}\StringTok{"MD004"}\NormalTok{ ,}\StringTok{"MD005"}\NormalTok{ ,}\StringTok{"MD006"}\NormalTok{ ,}\StringTok{"MD007"}\NormalTok{ ,}\StringTok{"MD009"}\NormalTok{ ,}\StringTok{"MD010"}\NormalTok{ ,}\StringTok{"MD011"}\NormalTok{ ,}\StringTok{"MD012"}\NormalTok{ ,}\StringTok{"MD014"}\NormalTok{ ,}\StringTok{"MD018"}\NormalTok{ ,}\StringTok{"MD019"}\NormalTok{ ,}\StringTok{"MD020"}\NormalTok{ ,}\StringTok{"MD021"}\NormalTok{ ,}\StringTok{"MD022"}\NormalTok{ ,}\StringTok{"MD023"}\NormalTok{ ,}\StringTok{"MD025"}\NormalTok{ ,}\StringTok{"MD026"}\NormalTok{ ,}\StringTok{"MD027"}\NormalTok{ ,}\StringTok{"MD028"}\NormalTok{ ,}\StringTok{"MD029"}\NormalTok{ ,}\StringTok{"MD030"}\NormalTok{ ,}\StringTok{"MD031"}\NormalTok{ ,}\StringTok{"MD032"}\NormalTok{ ,}\StringTok{"MD034"}\NormalTok{ ,}\StringTok{"MD035"}\NormalTok{ ,}\StringTok{"MD036"}\NormalTok{ ,}\StringTok{"MD037"}\NormalTok{ ,}\StringTok{"MD038"}\NormalTok{ ,}\StringTok{"MD039"} 
\end{Highlighting}
\end{Shaded}

\clearpage

\hypertarget{directory-structure}{%
\subsection{Directory Structure}\label{directory-structure}}

Relevant folders and files related to our build pipeline are shown
below. The users home directory and workspace subdirectory is implied
and removed from the diagram for clarity.

\begin{description}
\item[digraph folders \{]
"devsecops" {[}shape=folder{]}; ".github" {[}shape=folder{]};
"workflows" {[}shape=folder{]}; ".circleci" {[}shape=folder{]};
"config.yml" {[}shape=rectangle;{]} "docker\_compose.yml"
{[}shape=rectangle{]}; "packer.yml" {[}shape=rectangle{]}; "python.yml"
{[}shape=rectangle{]}; "markdown.yml" {[}shape=rectangle{]};
".travis.yml" {[}shape=rectangle{]}; ".mdlrc" {[}shape=rectangle{]};
".markdownlint.json" {[}shape=rectangle{]}; "devsecops" -\textgreater{}
".github"; "devsecops" -\textgreater{} ".mdlrc"; "devsecops"
-\textgreater{} ".travis.yml"; "devsecops" -\textgreater{}
".markdownlint.json"; "devsecops" -\textgreater{} ".circleci";
".circleci" -\textgreater{} "config.yml"; ".github" -\textgreater{}
"workflows"; "workflows" -\textgreater{} "docker\_compose.yml";
"workflows" -\textgreater{} "markdown.yml"; "workflows" -\textgreater{}
"packer.yml"; "workflows" -\textgreater{} "python.yml";
\end{description}

\}
