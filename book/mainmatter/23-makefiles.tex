\chapter{GNU Makefiles}

\includegraphics[scale=0.20]{images/books-1163695_1920.jpg}

\begin{displayquote}
	\emph{Make originated with a visit from Steve Johnson (author of yacc, etc.), storming into my office, cursing the Fates that had caused him to waste a morning debugging a correct program (bug had been fixed, file hadn't been compiled, cc *.o was therefore unaffected). As I had spent a part of the previous evening coping with the same disaster on a project I was working on, the idea of a tool to solve it came up. It began with an elaborate idea of a dependency analyzer, boiled down to something much simpler, and turned into Make that weekend. Use of tools that were still wet was part of the culture. Makefiles were text files, not magically encoded binaries, because that was the Unix ethos: printable, debuggable, understandable stuff.}
	
	Stuart Feldman \cite{raymond2004programming}
\end{displayquote}

\justifying
The GNU make tool is still around decades later for a reason. It has been battle-tested over the years and become a key tool for folks like us.
Originally intended for use in UNIX systems as an aid when compiling C projects, make is a handy way to put short sets of frequently used shell
commands at our fingertips. For make to function properly, you must create a Makefile\index{Makefile} in the directory
you invoke the make command from. Using a Makefile lets us avoid typing complicated and hard to recall strings on the command
line. You can simply type ``make docker'' and have everything build as desired from a list of commands in part of your Makefile. This is beneficial when
you have lots of arguments and environment variables that you and your team members need for sets of commands
to work properly. When your team member invokes a specific rule from a Makefile, it works without you having to
help them configure things or make them aware of all the parameters. We're going to be using \href{https://www.gnu.org/software/make/}{GNU Make} for our projects.

\justifying
With Python projects, I like to use make to kick off builds and unit tests in a virtual environment, perhaps with differing sets of requirements files. When we build a
python application we might call on ``requirements.txt'' for the dependencies we need. The list of requirements are then installed using pip. When we test, we might have
another file called ``requirements-test.txt'' that gets installed with or in place of the usual requirements. Similarly with Ruby, there may be a need for different Gemfiles
depending on your activity. Using make with Docker and docker-compose can be beneficial for building and running images locally.

\justifying
A Makefile can be as simple as a few lines or grow to become an extremely intricate and vital piece of your
build environment. You might like to have a look at
\href{https://www.gnu.org/software/make/manual/make.html#Introduction}{the GNU make manual} at least once just to get a feel for how they work.

\justifying
When a Makefile is executed, you can use the ampersand character to suppress the printing of lines from the original Makefile.

\section{Rules}

\justifying
Makefiles are comprised of various stanzas, know as rules. This is where the work gets done. Let's consider a rule
for Docker and a target for Python to make our lives easier in the future. Here is how a Makefile with the rule added..

\justifying
\begin{mybox}{\thetcbcounter: Our First Makefile}
	\lstinputlisting{code/23-makefiles/simple-makefile}
\end{mybox}

\justifying
It's important to note that indentation of Makefiles is done using tabs rather than spaces. If your Makefile is failing, check for spots where lines were improperly
indented with eight spaces rather than a tab character. The proper way to indent in a Makefile is to use one or more tab characters.

\section{The PHONY Directive}

\justifying
If a file or directory exists with the same name as a rule in the Makefile, you will need to specify
it under the PHONY directive. This will allow the Makefile to find and run the desired commands.

\justifying
\begin{mybox}{\thetcbcounter: The PHONY Directive}
	\lstinputlisting{code/23-makefiles/phony-makefile}
\end{mybox}

% lab 6a

\section{Variables and Conditionals in a Makefile}

\justifying
Conditional operators and variables can be specified in a Makefile. Note that variables and conditionals do not observe the save rules with respect to tab based indentation.

\justifying
Let's look at a simple Makefile example for checking if two programs are installed. Here we have a Makefile
with a single target, ``clean''. The first two lines of this Makefile run shell commands to determine
whether ``kubectl'' and ``tkn'' are installed in the current environment.

\begin{mybox}{\thetcbcounter: Conditionals and Variable Example}
	\lstinputlisting{{listing options={style=tcblatex,numbers=left,numberstyle=\tiny\color{red!75!black}}}code/23-makefiles/6b-Makefile}
\end{mybox}

\section{Large Example Makefile}
\justifying
Let's consider a larger Makefile so we can get familiar with more of the elements.

\section{Directory Structure with Makefile}

\justifying
Relevant files and folders related to our Makefile are organized as seen below.

\begin{figure}[!htb]
	\input{dot/23-makefile.tex}
	\caption{Makefile and related files.}
\label{makefile}
\end{figure}

